<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tile Map Editor PRO — Siedler 2020</title>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --muted:#2a2f3a; --text:#e8ecf1; --acc:#5aa0ff; --soft:#9fbef7; --warn:#ff7a7a;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--text);}
  header{display:flex;gap:12px;align-items:center;padding:10px 14px;background:linear-gradient(180deg,#151923,#11151d);border-bottom:1px solid #121620;position:sticky;top:0;z-index:5}
  header h1{font-size:16px;margin:0 8px 0 0;font-weight:600;letter-spacing:.2px}
  header .group{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  header label{font-size:12px;opacity:.8;margin-right:4px}
  header input[type="number"], header select{background:#0e121a;border:1px solid #232a36;border-radius:6px;color:var(--text);padding:6px 8px;min-width:60px}
  header button{background:var(--muted);border:1px solid #2e3542;color:var(--text);padding:7px 10px;border-radius:7px;font-weight:600;cursor:pointer}
  header button.primary{background:var(--acc);border-color:#3b7ee8;color:#081223}
  header button.ghost{background:transparent;border-color:#2e3542}
  header button:disabled{opacity:.5;cursor:not-allowed}
  #app{display:grid;grid-template-columns: 280px 1fr 320px;grid-template-rows: 1fr;gap:10px;height:calc(100vh - 56px);padding:10px}
  aside, .right{background:var(--panel);border:1px solid #1c2130;border-radius:10px;overflow:auto}
  .section{padding:10px 10px 8px;border-bottom:1px solid #1c2130}
  .section:last-child{border-bottom:none}
  h2{font-size:13px;margin:0 0 6px 0;opacity:.9}
  .tiles{display:grid;grid-template-columns:repeat(auto-fill,minmax(48px,1fr));gap:8px;padding:8px}
  .tile{border:1px solid #2b3241;border-radius:8px;background:#0f1320;cursor:pointer;overflow:hidden;position:relative}
  .tile.selected{outline:2px solid var(--acc);}
  .tile img{display:block;width:100%;height:100%;object-fit:contain;background:#0b0f18}
  .tile small{position:absolute;bottom:4px;left:4px;background:rgba(0,0,0,.55);padding:2px 5px;border-radius:6px;font-size:10px}
  .layer{display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px solid #273041;border-radius:8px;margin:6px;background:#0f1421}
  .layer input[type="checkbox"]{margin-right:6px}
  .toolrow{display:flex;gap:8px;flex-wrap:wrap}
  .toolrow button{padding:6px 8px;border-radius:8px;border:1px solid #2b3241;background:#101623;color:var(--text);cursor:pointer}
  .toolrow button.active{outline:2px solid var(--acc)}
  canvas{background:#0b0f16;display:block;width:100%;height:100%;image-rendering: pixelated;image-rendering: crisp-edges;border-radius:10px}
  #canvasWrap{position:relative;height:100%;}
  #overlay{position:absolute;inset:0;pointer-events:none}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0d121a;border:1px solid #2c3444;padding:1px 4px;border-radius:6px;font-size:12px}
  .hint{font-size:12px;opacity:.8}
  footer{position:sticky;bottom:0;background:#121723;border-top:1px solid #1c2130;padding:8px 12px;font-size:12px;opacity:.9}
  .pill{display:inline-flex;align-items:center;gap:6px;background:#0d1421;border:1px solid #273041;border-radius:999px;padding:4px 10px;font-size:12px;margin-right:8px}
  input[type="file"]{display:none}
  .drop{border:1px dashed #2e3749;background:#0b1020;border-radius:10px;padding:12px;text-align:center;color:#b9c8e7;margin-top:8px}
  .drop.dragover{background:#0e1530}
  .tabbar{display:flex;gap:6px}
  .tabbar button{padding:6px 10px;border-radius:999px}
  .tabbar button.active{background:var(--acc);color:#091221;border-color:#3b7ee8}
  .minimap{width:100%;height:160px;border:1px solid #273041;border-radius:8px;background:#0a1119}
  .stamp-list{display:grid;grid-template-columns:repeat(auto-fill,minmax(64px,1fr));gap:8px;padding:8px}
  .stamp{border:1px solid #2b3241;border-radius:8px;background:#0f1320;padding:4px;cursor:pointer;position:relative}
  .stamp.selected{outline:2px solid var(--acc)}
  .badge{position:absolute;top:4px;right:4px;background:rgba(0,0,0,.55);padding:2px 5px;border-radius:6px;font-size:10px}
  .danger{color:var(--warn)}
  .toggle{display:inline-flex;gap:8px;align-items:center}
</style>
</head>
<body>
<header>
  <h1>Tile Map Editor PRO</h1>
  <div class="group tabbar">
    <button id="btnBuild" class="ghost">Bauen</button>
    <button id="btnEditor" class="primary active">Map‑Editor</button>
  </div>
  <div class="group">
    <label>Tilegröße</label>
    <select id="tileSize">
      <option>16</option><option selected>32</option><option>48</option><option>64</option><option>128</option>
    </select>
  </div>
  <div class="group">
    <label>Map (BxH, in Tiles)</label>
    <input type="number" id="mapW" value="64" min="1" max="512"/>
    <input type="number" id="mapH" value="64" min="1" max="512"/>
    <button id="resizeBtn">Neu aufsetzen</button>
  </div>
  <div class="group">
    <button id="gridBtn" class="primary">Grid an</button>
    <button id="undoBtn" title="Strg+Z">Undo</button>
    <button id="redoBtn" title="Strg+Y">Redo</button>
  </div>
  <div class="group">
    <button id="saveJson">Export JSON</button>
    <button id="loadJson">Import JSON</button>
    <button id="exportPng" class="primary">Export PNG</button>
  </div>
</header>

<div id="app">
  <aside id="leftPane">
    <div class="section">
      <h2>Tiles</h2>
      <div class="toolrow" style="margin-bottom:6px">
        <label for="tileFiles" class="button"><button>Tiles hinzufügen</button></label>
        <input id="tileFiles" type="file" accept="image/*" multiple />
        <button id="clearTiles">Leeren</button>
      </div>
      <div id="dropZone" class="drop">Bilder hierher ziehen oder <span class="kbd">Tiles hinzufügen</span> klicken</div>
    </div>
    <div class="section">
      <h2>Spritesheet‑Importer</h2>
      <div class="toolrow">
        <label for="sheetFile"><button>Spritesheet laden</button></label>
        <input id="sheetFile" type="file" accept="image/*" />
      </div>
      <div class="toolrow">
        <label>Tile W <input id="sheetTw" type="number" value="32" style="width:70px"></label>
        <label>Tile H <input id="sheetTh" type="number" value="32" style="width:70px"></label>
      </div>
      <div class="toolrow">
        <label>Margin <input id="sheetMargin" type="number" value="0" style="width:70px"></label>
        <label>Spacing <input id="sheetSpacing" type="number" value="0" style="width:70px"></label>
        <button id="sheetSlice">Zerschneiden</button>
      </div>
    </div>
    <div class="tiles" id="palette"></div>
  </aside>

  <main style="display:flex;flex-direction:column;gap:8px;min-width:0;">
    <div class="section">
      <div class="toolrow">
        <button id="toolBrush" class="active">Pinsel (B)</button>
        <button id="toolEraser">Radierer (E)</button>
        <button id="toolPicker">Pipette (I)</button>
        <button id="toolFill">Flood‑Fill (F)</button>
        <button id="toolStamp">Stempel (S)</button>
        <button id="toolMeta">Meta (M)</button>
        <button id="toolPan">Verschieben (Leertaste)</button>
        <label style="margin-left:12px;">Brush:
          <select id="brushSize">
            <option value="1" selected>1×1</option>
            <option value="2">2×2</option>
            <option value="3">3×3</option>
          </select>
        </label>
        <label style="margin-left:12px;">Zoom: <span id="zoomLbl" class="kbd">100%</span></label>
        <label class="toggle" style="margin-left:auto;">
          <input type="checkbox" id="collisionToggle"> Kollisions‑Modus
        </label>
      </div>
      <div class="hint">Stempel erstellen: <span class="kbd">S</span> aktivieren, dann <b>Shift</b> gedrückt halten und mit der Maus einen Bereich auf der Karte aufziehen. Der Stempel erscheint rechts in der Liste.</div>
    </div>
    <div id="canvasWrap">
      <canvas id="map" width="1024" height="768"></canvas>
      <canvas id="overlay"></canvas>
    </div>
    <footer>
      <span class="pill">Maus links: malen • Rechts: pannen • Rad: zoomen</span>
      <span class="pill">Hotkeys: <span class="kbd">B</span> Pinsel • <span class="kbd">E</span> Radierer • <span class="kbd">I</span> Pipette • <span class="kbd">F</span> Fill • <span class="kbd">S</span> Stempel • <span class="kbd">M</span> Meta • <span class="kbd">G</span> Grid • <span class="kbd">Strg+S</span> JSON speichern</span>
      <span class="hint" id="status">Bereit.</span>
    </footer>
  </main>

  <div class="right">
    <div class="section">
      <h2>Ebenen</h2>
      <div id="layers"></div>
      <div class="toolrow" style="margin-top:8px">
        <button id="addLayer">Ebene +</button>
        <button id="delLayer">Ebene –</button>
      </div>
    </div>
    <div class="section">
      <h2>Stempel</h2>
      <div class="toolrow">
        <button id="clearStamps">Stempel leeren</button>
      </div>
      <div id="stamps" class="stamp-list"></div>
    </div>
    <div class="section">
      <h2>Mini‑Map</h2>
      <canvas id="minimap" class="minimap"></canvas>
    </div>
    <div class="section">
      <h2>Projekt</h2>
      <div class="toolrow">
        <button id="newProject">Neu (leer)</button>
        <button id="fitBtn">Auf Inhalt zoomen</button>
      </div>
    </div>
    <div class="section">
      <h2>Info</h2>
      <div style="font-size:12px;line-height:1.35;">
        Getrennte Modi: <b>Bauen</b> (nur UI‑Umschalter) & <b>Map‑Editor</b>.<br/>
        Flood‑Fill, Kachel‑Stempel (Multi‑Tile), Kollisions‑Layer (separat), per‑Tile‑Metadata.<br/>
        Spritesheet‑Importer schneidet Atlas automatisch in Tiles.
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = (q)=>document.querySelector(q);
  const $$ = (q)=>document.querySelectorAll(q);
  const canvas = $('#map');
  const overlay = $('#overlay');
  const ctx = canvas.getContext('2d');
  const octx = overlay.getContext('2d', { willReadFrequently: true });
  const minimap = $('#minimap');
  const mctx = minimap.getContext('2d');
  let state = {
    tileSize: 32,
    mapW: 64,
    mapH: 64,
    zoom: 1,
    offX: 0,
    offY: 0,
    showGrid: true,
    tool: 'brush', // brush | eraser | picker | fill | stamp | meta | pan
    brush: 1,
    tiles: [], // {id, name, img}
    selectedTile: null,
    layers: [], // {name, data: Int32Array, visible: true}
    activeLayer: 0,
    history: [],
    future: [],
    isPanning: false,
    mouseDown: false,
    lastPainted: new Set(),
    collisionMode: false,
    collisions: null, // Uint8Array size mapW*mapH (0/1)
    meta: {}, // index -> object
    stamps: [], // {w,h,data:Int32Array,thumb:canvas}
    selectedStamp: -1,
    selecting:false, selStart:null, selEnd:null,
  };

  function setStatus(msg){ $('#status').textContent = msg; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function idx(x,y,w){ return y*w + x; }
  function tileIndex(x,y){ return y*state.mapW + x; }
  function worldToTile(wx, wy){
    const x = Math.floor((wx - state.offX)/(state.tileSize*state.zoom));
    const y = Math.floor((wy - state.offY)/(state.tileSize*state.zoom));
    return {x,y};
  }
  function tileToScreen(x, y){
    return {
      x: Math.floor(state.offX + x*state.tileSize*state.zoom),
      y: Math.floor(state.offY + y*state.tileSize*state.zoom),
    };
  }

  function ensureActiveLayer(){
    if(state.layers.length===0){
      addLayer('Ground');
      addLayer('Objects');
      state.activeLayer = 0;
      refreshLayers();
    }
    if(!state.collisions){
      state.collisions = new Uint8Array(state.mapW*state.mapH);
    }
  }

  function addLayer(name){
    const data = new Int32Array(state.mapW*state.mapH).fill(-1);
    state.layers.push({name, data, visible:true});
  }

  function deleteLayer(idx){
    if(state.layers.length<=1) return;
    state.layers.splice(idx,1);
    state.activeLayer = clamp(state.activeLayer,0,state.layers.length-1);
  }

  function resizeMap(w,h){
    w = clamp(w,1,512); h = clamp(h,1,512);
    const oldW = state.mapW, oldH = state.mapH;
    state.mapW = w; state.mapH = h;
    for(const L of state.layers){
      const old = L.data;
      const nd = new Int32Array(w*h).fill(-1);
      for(let y=0;y<Math.min(h,oldH);y++){
        for(let x=0;x<Math.min(w,oldW);x++){
          nd[idx(x,y,w)] = old[idx(x,y,oldW)];
        }
      }
      L.data = nd;
    }
    const oldC = state.collisions || new Uint8Array(oldW*oldH);
    const nc = new Uint8Array(w*h);
    for(let y=0;y<Math.min(h,oldH);y++){
      for(let x=0;x<Math.min(w,oldW);x++){
        nc[idx(x,y,w)] = oldC[idx(x,y,oldW)];
      }
    }
    state.collisions = nc;
    fitOverlay();
    draw();
  }

  function fitOverlay(){
    overlay.width = canvas.clientWidth;
    overlay.height = canvas.clientHeight;
    overlay.style.width = canvas.clientWidth+'px';
    overlay.style.height = canvas.clientHeight+'px';
  }

  function setCanvasSize(){
    const wrap = document.getElementById('canvasWrap');
    const w = wrap.clientWidth;
    const h = wrap.clientHeight - 0;
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    fitOverlay();
    draw();
  }
  window.addEventListener('resize', setCanvasSize);

  // ---------- Tiles & Palette
  const palette = $('#palette');
  function addTileFromFile(file){
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=>{
      const id = state.tiles.length;
      state.tiles.push({id, name:file.name, img});
      addTileThumb(id);
      if(state.selectedTile===null){ selectTile(0); }
      URL.revokeObjectURL(url);
    };
    img.src = url;
  }
  function addTileFromImageBlob(blob, name='Tile'){
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = ()=>{
      const id = state.tiles.length;
      state.tiles.push({id, name, img});
      addTileThumb(id);
      if(state.selectedTile===null){ selectTile(0); }
      URL.revokeObjectURL(url);
    };
    img.src = url;
  }
  function addTileThumb(id){
    const t = state.tiles[id];
    const div = document.createElement('div');
    div.className = 'tile';
    div.dataset.id = id;
    const im = document.createElement('img');
    im.src = t.img.src;
    const cap = document.createElement('small');
    cap.textContent = (t.name || ('Tile '+id)).slice(0,16);
    div.appendChild(im); div.appendChild(cap);
    div.addEventListener('click', ()=> selectTile(id));
    palette.appendChild(div);
  }
  function selectTile(id){
    state.selectedTile = id;
    $$('.tile').forEach(el=>el.classList.toggle('selected', Number(el.dataset.id)===id));
    state.selectedStamp = -1;
    $$('.stamp').forEach(el=>el.classList.remove('selected'));
    setStatus(`Tile ausgewählt: #${id}`);
  }

  $('#tileFiles').addEventListener('change', (e)=>{
    [...e.target.files].forEach(addTileFromFile);
    e.target.value = '';
  });
  $('#clearTiles').addEventListener('click', ()=>{
    state.tiles = [];
    state.selectedTile = null;
    palette.innerHTML='';
    draw();
  });
  const dz = $('#dropZone');
  ;['dragenter','dragover'].forEach(ev=>dz.addEventListener(ev, e=>{e.preventDefault(); dz.classList.add('dragover');}));
  ;['dragleave','drop'].forEach(ev=>dz.addEventListener(ev, e=>{e.preventDefault(); dz.classList.remove('dragover');}));
  dz.addEventListener('drop', (e)=>{
    const files = [...e.dataTransfer.files].filter(f=>f.type.startsWith('image/'));
    files.forEach(addTileFromFile);
  });

  // Spritesheet importer
  let sheetImg = null;
  $('#sheetFile').addEventListener('change', (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const url = URL.createObjectURL(f);
    sheetImg = new Image();
    sheetImg.onload = ()=>{ setStatus('Spritesheet geladen. Parameter einstellen und "Zerschneiden" drücken.'); URL.revokeObjectURL(url); };
    sheetImg.src = url;
  });
  $('#sheetSlice').addEventListener('click', ()=>{
    if(!sheetImg){ setStatus('Kein Spritesheet geladen.'); return; }
    const tw = Number($('#sheetTw').value)||32;
    const th = Number($('#sheetTh').value)||32;
    const margin = Number($('#sheetMargin').value)||0;
    const spacing = Number($('#sheetSpacing').value)||0;
    const cols = Math.floor((sheetImg.width - margin + spacing)/(tw+spacing));
    const rows = Math.floor((sheetImg.height - margin + spacing)/(th+spacing));
    const off = document.createElement('canvas');
    off.width = tw; off.height = th;
    const c = off.getContext('2d');
    let added = 0;
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const sx = margin + x*(tw+spacing);
        const sy = margin + y*(th+spacing);
        if(sx+tw<=sheetImg.width && sy+th<=sheetImg.height){
          c.clearRect(0,0,tw,th);
          c.drawImage(sheetImg, sx, sy, tw, th, 0,0,tw,th);
          off.toBlob((blob)=> addTileFromImageBlob(blob, `sheet_${x}_${y}.png`));
          added++;
        }
      }
    }
    setStatus(`${added} Tiles aus Spritesheet geschnitten.`);
  });

  // ---------- Layers UI
  function refreshLayers(){
    const box = $('#layers');
    box.innerHTML='';
    state.layers.forEach((L, i)=>{
      const row = document.createElement('div');
      row.className='layer';
      row.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;flex:1">
          <input type="radio" name="activeLayer" ${i===state.activeLayer?'checked':''} data-i="${i}" title="Aktive Ebene"/>
          <input type="checkbox" ${L.visible?'checked':''} data-i="${i}" title="Sichtbar"/>
          <input type="text" value="${L.name}" data-i="${i}" style="flex:1;background:#0a0f18;border:1px solid #2c3342;border-radius:6px;color:#dfe7f3;padding:6px 8px"/>
        </div>
        <span class="kbd">${i}</span>
      `;
      box.appendChild(row);
    });
    box.querySelectorAll('input[type="radio"]').forEach(r=>r.addEventListener('change', (e)=>{
      state.activeLayer = Number(e.target.dataset.i);
      setStatus('Aktive Ebene: '+state.layers[state.activeLayer].name);
    }));
    box.querySelectorAll('input[type="checkbox"]').forEach(c=>c.addEventListener('change', (e)=>{
      const i = Number(e.target.dataset.i); state.layers[i].visible = e.target.checked; draw();
    }));
    box.querySelectorAll('input[type="text"]').forEach(t=>t.addEventListener('input', (e)=>{
      const i = Number(e.target.dataset.i); state.layers[i].name = e.target.value;
    }));
  }
  $('#addLayer').addEventListener('click', ()=>{ addLayer('Layer '+state.layers.length); refreshLayers(); draw(); });
  $('#delLayer').addEventListener('click', ()=>{ deleteLayer(state.activeLayer); refreshLayers(); draw(); });

  // ---------- Tools
  function setTool(t){
    state.tool = t;
    ['brush','eraser','picker','fill','stamp','meta','pan'].forEach(id=>$('#tool'+id.charAt(0).toUpperCase()+id.slice(1)).classList.toggle('active', t===id));
    setStatus('Tool: '+t);
  }
  $('#toolBrush').onclick = ()=>setTool('brush');
  $('#toolEraser').onclick = ()=>setTool('eraser');
  $('#toolPicker').onclick = ()=>setTool('picker');
  $('#toolFill').onclick = ()=>setTool('fill');
  $('#toolStamp').onclick = ()=>setTool('stamp');
  $('#toolMeta').onclick = ()=>setTool('meta');
  $('#toolPan').onclick = ()=>setTool('pan');
  $('#brushSize').addEventListener('change', (e)=>{ state.brush = Number(e.target.value); });
  $('#tileSize').addEventListener('change', (e)=>{ state.tileSize = Number(e.target.value); draw(); });

  // Build / Editor tabs
  $('#btnBuild').addEventListener('click', ()=>{
    $('#btnBuild').classList.add('active'); $('#btnEditor').classList.remove('active');
    setStatus('Bauen‑Modus (UI‑Umschalter).');
  });
  $('#btnEditor').addEventListener('click', ()=>{
    $('#btnEditor').classList.add('active'); $('#btnBuild').classList.remove('active');
    setStatus('Map‑Editor aktiv.');
  });

  // Collision mode
  $('#collisionToggle').addEventListener('change',(e)=>{
    state.collisionMode = e.target.checked;
    setStatus(state.collisionMode? 'Kollisions‑Modus aktiv: Linksklick toggelt Blockade.' : 'Kollisions‑Modus aus.');
    draw();
  });

  // ---------- History
  function pushHistory(payload){
    state.history.push(payload);
    if(state.history.length>500) state.history.shift();
    state.future.length = 0;
  }

  function applyPaint(paints, label='paint'){
    if(state.collisionMode){
      const prev = paints.map(p=>({i:p.i, prev: state.collisions[p.i]}));
      pushHistory({type:'collision', changes:prev});
      for(const p of paints){ state.collisions[p.i] = p.v; }
      draw(); return;
    }
    const L = state.layers[state.activeLayer];
    const prev = paints.map(p=>({i:p.i, prev:L.data[p.i]}));
    pushHistory({type:label, layer:state.activeLayer, changes:prev});
    for(const p of paints){ L.data[p.i] = p.v; }
    draw();
  }

  function undo(){
    const h = state.history.pop(); if(!h) return;
    state.future.push(h);
    if(h.type==='paint' || h.type==='erase'){
      const L = state.layers[h.layer];
      h.changes.forEach(c=>{ L.data[c.i] = c.prev; });
    } else if(h.type==='collision'){
      h.changes.forEach(c=>{ state.collisions[c.i] = c.prev; });
    } else if(h.type==='import'){
      Object.assign(state, structuredClone(h.prev));
      fitOverlay();
    } else if(h.type==='meta'){
      state.meta = structuredClone(h.prevMeta);
    }
    draw();
  }

  function redo(){
    const h = state.future.pop(); if(!h) return;
    state.history.push(h);
    if(h.type==='paint' || h.type==='erase'){
      const L = state.layers[h.layer];
      h.changes.forEach(c=>{ L.data[c.i] = c.next ?? c.v ?? c.prev; });
    } else if(h.type==='collision'){
      h.changes.forEach(c=>{ state.collisions[c.i] = c.next ?? (c.prev?0:1); });
    } else if(h.type==='import'){
      Object.assign(state, structuredClone(h.next));
      fitOverlay();
    } else if(h.type==='meta'){
      state.meta = structuredClone(h.nextMeta);
    }
    draw();
  }

  $('#undoBtn').onclick = undo;
  $('#redoBtn').onclick = redo;

  // ---------- Painting & input
  function paintAt(mx,my){
    const {x,y} = worldToTile(mx,my);
    const bs = state.brush;
    if(state.tool==='stamp' && state.selectedStamp>=0){
      const st = state.stamps[state.selectedStamp]; if(!st) return;
      const paints = [];
      for(let sy=0; sy<st.h; sy++){
        for(let sx=0; sx<st.w; sx++){
          const tx = x+sx, ty=y+sy;
          if(tx<0||ty<0||tx>=state.mapW||ty>=state.mapH) continue;
          const v = st.data[idx(sx,sy,st.w)];
          if(v>=-1){
            const i = tileIndex(tx,ty);
            if(state.lastPainted.has(i)) continue;
            state.lastPainted.add(i);
            if(v>=0) paints.push({i, v});
            else paints.push({i, v:-1});
          }
        }
      }
      if(paints.length) applyPaint(paints, 'paint');
      return;
    }
    if(state.tool==='fill'){
      floodFill(x,y);
      return;
    }
    const paints = [];
    for(let dy=0; dy<bs; dy++){
      for(let dx=0; dx<bs; dx++){
        const tx = x+dx, ty=y+dy;
        if(tx<0||ty<0||tx>=state.mapW||ty>=state.mapH) continue;
        const i = tileIndex(tx,ty);
        if(state.lastPainted.has(i)) continue;
        state.lastPainted.add(i);
        if(state.tool==='brush' && state.selectedTile!==null){
          paints.push({i, v: state.selectedTile});
        } else if(state.tool==='eraser'){
          paints.push({i, v: -1});
        }
      }
    }
    if(paints.length){
      applyPaint(paints, state.tool==='eraser'?'erase':'paint');
    }
  }

  function pickAt(mx,my){
    const {x,y} = worldToTile(mx,my);
    if(x<0||y<0||x>=state.mapW||y>=state.mapH) return;
    if(state.collisionMode){
      const i = tileIndex(x,y);
      const v = state.collisions[i];
      applyPaint([{i, v: v?0:1}], 'collision');
      return;
    }
    if(state.tool==='meta'){
      const i = tileIndex(x,y);
      const prev = structuredClone(state.meta);
      const json = prompt('Tile‑Metadata als JSON (z.B. {"biome":"forest","cost":2})', JSON.stringify(state.meta[i]||{}));
      if(json!==null){
        try{
          const obj = JSON.parse(json);
          pushHistory({type:'meta', prevMeta: prev, nextMeta: Object.assign({}, prev, {[i]:obj})});
          state.meta[i] = obj;
          setStatus('Metadata gesetzt.');
        }catch(err){
          alert('Ungültiges JSON.');
        }
      }
      return;
    }
    for(let li=state.layers.length-1; li>=0; li--){
      const L = state.layers[li];
      if(!L.visible) continue;
      const v = L.data[tileIndex(x,y)];
      if(v>=0){ selectTile(v); break; }
    }
  }

  function floodFill(x,y){
    if(x<0||y<0||x>=state.mapW||y>=state.mapH) return;
    if(state.collisionMode){
      const target = state.collisions[tileIndex(x,y)];
      const newVal = target?0:1;
      const paints = [];
      const q=[[x,y]]; const seen=new Set([tileIndex(x,y)]);
      while(q.length){
        const [cx,cy]=q.pop();
        const i = tileIndex(cx,cy);
        if(state.collisions[i]!==target) continue;
        paints.push({i, v:newVal});
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          const nx=cx+dx, ny=cy+dy;
          if(nx>=0&&ny>=0&&nx<state.mapW&&ny<state.mapH){
            const ni = tileIndex(nx,ny);
            if(!seen.has(ni) && state.collisions[ni]===target){ seen.add(ni); q.push([nx,ny]); }
          }
        });
      }
      applyPaint(paints, 'collision');
      return;
    }
    const L = state.layers[state.activeLayer];
    const target = L.data[tileIndex(x,y)];
    const replacement = state.selectedTile;
    if(replacement===null || replacement===target) return;
    const paints = [];
    const q=[[x,y]]; const seen=new Set([tileIndex(x,y)]);
    while(q.length){
      const [cx,cy]=q.pop();
      const i = tileIndex(cx,cy);
      if(L.data[i]!==target) continue;
      paints.push({i, v:replacement});
      [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
        const nx=cx+dx, ny=cy+dy;
        if(nx>=0&&ny>=0&&nx<state.mapW&&ny<state.mapH){
          const ni = tileIndex(nx,ny);
          if(!seen.has(ni) && L.data[ni]===target){ seen.add(ni); q.push([nx,ny]); }
        }
      });
    }
    if(paints.length) applyPaint(paints,'paint');
  }

  let lastX=0,lastY=0;
  canvas.addEventListener('mousedown', (e)=>{
    if(e.button===2 || state.tool==='pan'){ state.isPanning = true; lastX=e.clientX; lastY=e.clientY; return; }
    if(e.shiftKey && state.tool==='stamp'){
      state.selecting=true; state.selStart = worldToTile(e.clientX,e.clientY); state.selEnd = {...state.selStart}; draw(); return;
    }
    state.mouseDown = true; state.lastPainted.clear();
    if(state.tool==='picker' || state.tool==='meta'){ pickAt(e.clientX, e.clientY); return; }
    paintAt(e.clientX, e.clientY);
  });
  canvas.addEventListener('mousemove', (e)=>{
    if(state.isPanning){ state.offX += (e.clientX-lastX); state.offY += (e.clientY-lastY); lastX=e.clientX; lastY=e.clientY; draw(); return; }
    if(state.selecting){ state.selEnd = worldToTile(e.clientX,e.clientY); draw(); return; }
    if(state.mouseDown){ paintAt(e.clientX, e.clientY); }
  });
  window.addEventListener('mouseup', ()=>{
    state.mouseDown=false; state.isPanning=false; state.lastPainted.clear();
    if(state.selecting){
      state.selecting=false;
      const x0 = Math.min(state.selStart.x, state.selEnd.x);
      const y0 = Math.min(state.selStart.y, state.selEnd.y);
      const x1 = Math.max(state.selStart.x, state.selEnd.x);
      const y1 = Math.max(state.selStart.y, state.selEnd.y);
      const w = clamp(x1-x0+1,1,state.mapW);
      const h = clamp(y1-y0+1,1,state.mapH);
      const L = state.layers[state.activeLayer];
      const data = new Int32Array(w*h);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          data[idx(x,y,w)] = L.data[tileIndex(x0+x,y0+y)];
        }
      }
      const thumb = document.createElement('canvas');
      thumb.width = w*8; thumb.height = h*8;
      const tc = thumb.getContext('2d');
      tc.fillStyle = '#1b2230'; tc.fillRect(0,0,thumb.width,thumb.height);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const v = data[idx(x,y,w)];
          tc.fillStyle = v>=0 ? '#6aa4ff' : '#2a3244';
          tc.fillRect(x*8+1,y*8+1,6,6);
        }
      }
      state.stamps.push({w,h,data,thumb});
      renderStamps();
      setStatus(`Stempel erstellt: ${w}×${h}`);
    }
  });

  canvas.addEventListener('contextmenu', e=>e.preventDefault());

  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const mouseX = e.clientX, mouseY = e.clientY;
    const before = worldToTile(mouseX, mouseY);
    const k = e.deltaY>0 ? 0.9 : 1.1;
    state.zoom = clamp(state.zoom * k, 0.25, 6);
    $('#zoomLbl').textContent = Math.round(state.zoom*100)+'%';
    const after = worldToTile(mouseX, mouseY);
    state.offX += (before.x - after.x) * state.tileSize * state.zoom;
    state.offY += (before.y - after.y) * state.tileSize * state.zoom;
    draw();
  }, {passive:false});

  window.addEventListener('keydown', (e)=>{
    if(e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
    else if(e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
    else if(e.ctrlKey && e.key.toLowerCase()==='s'){ e.preventDefault(); saveJSON(); }
    else if(e.key.toLowerCase()==='b'){ setTool('brush'); }
    else if(e.key.toLowerCase()==='e'){ setTool('eraser'); }
    else if(e.key.toLowerCase()==='i'){ setTool('picker'); }
    else if(e.key.toLowerCase()==='f'){ setTool('fill'); }
    else if(e.key.toLowerCase()==='s'){ setTool('stamp'); }
    else if(e.key.toLowerCase()==='m'){ setTool('meta'); }
    else if(e.key.toLowerCase()==='g'){ toggleGrid(); }
    else if(e.key===' '){ setTool('pan'); }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.key===' ' && state.tool==='pan'){ setTool('brush'); }
  });

  function clear(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    octx.clearRect(0,0,overlay.width,overlay.height);
  }
  function drawGrid(){
    if(!state.showGrid) return;
    octx.save();
    octx.globalAlpha = .3;
    octx.strokeStyle = '#324056';
    octx.lineWidth = 1;
    const step = Math.floor(state.tileSize*state.zoom);
    const startX = (state.offX % step + step) % step;
    const startY = (state.offY % step + step) % step;
    for(let x=startX; x<overlay.width; x+=step){
      octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,overlay.height); octx.stroke();
    }
    for(let y=startY; y<overlay.height; y+=step){
      octx.beginPath(); octx.moveTo(0,y); octx.lineTo(overlay.width,y); octx.stroke();
    }
    octx.restore();
  }
  function drawSelection(){
    if(!state.selecting) return;
    const x0 = Math.min(state.selStart.x, state.selEnd.x);
    const y0 = Math.min(state.selStart.y, state.selEnd.y);
    const x1 = Math.max(state.selStart.x, state.selEnd.x);
    const y1 = Math.max(state.selStart.y, state.selEnd.y);
    const p0 = tileToScreen(x0,y0);
    const p1 = tileToScreen(x1+1,y1+1);
    octx.save();
    octx.globalAlpha = .25;
    octx.fillStyle = '#5aa0ff';
    octx.fillRect(p0.x, p0.y, (p1.x-p0.x), (p1.y-p0.y));
    octx.restore();
  }
  function draw(){
    clear();
    const ts = state.tileSize*state.zoom;
    const startX = Math.floor((-state.offX)/ts)-1;
    const startY = Math.floor((-state.offY)/ts)-1;
    const endX = Math.ceil((canvas.width - state.offX)/ts)+1;
    const endY = Math.ceil((canvas.height - state.offY)/ts)+1;
    for(let li=0; li<state.layers.length; li++){
      const L = state.layers[li];
      if(!L.visible) continue;
      for(let y=startY; y<endY; y++){
        if(y<0||y>=state.mapH) continue;
        for(let x=startX; x<endX; x++){
          if(x<0||x>=state.mapW) continue;
          const idx2 = tileIndex(x,y);
          const v = L.data[idx2];
          if(v>=0){
            const t = state.tiles[v];
            if(t){
              const p = tileToScreen(x,y);
              ctx.drawImage(t.img, p.x, p.y, ts, ts);
            }
          }
        }
      }
    }
    if(state.collisionMode){
      octx.save();
      octx.globalAlpha = 0.35;
      octx.fillStyle = '#ff5757';
      for(let y=startY; y<endY; y++){
        if(y<0||y>=state.mapH) continue;
        for(let x=startX; x<endX; x++){
          if(x<0||x>=state.mapW) continue;
          const i = tileIndex(x,y);
          if(state.collisions[i]){
            const p = tileToScreen(x,y);
            octx.fillRect(p.x, p.y, ts, ts);
          }
        }
      }
      octx.restore();
    }
    drawGrid();
    drawSelection();
    drawMinimap();
  }

  function drawMinimap(){
    const w = minimap.clientWidth|0, h = minimap.clientHeight|0;
    minimap.width = w; minimap.height = h;
    mctx.fillStyle = '#0a0f15'; mctx.fillRect(0,0,w,h);
    const tw = w / state.mapW;
    const th = h / state.mapH;
    for(const L of state.layers){
      if(!L.visible) continue;
      mctx.globalAlpha = 0.9;
      for(let y=0;y<state.mapH;y++){
        for(let x=0;x<state.mapW;x++){
          const v = L.data[tileIndex(x,y)];
          if(v>=0){
            mctx.fillStyle = '#6aa4ff';
            mctx.fillRect(Math.floor(x*tw), Math.floor(y*th), Math.ceil(tw), Math.ceil(th));
          }
        }
      }
    }
    if(state.collisionMode){
      mctx.globalAlpha = 0.5;
      mctx.fillStyle = '#ff5757';
      for(let y=0;y<state.mapH;y++){
        for(let x=0;x<state.mapW;x++){
          if(state.collisions[tileIndex(x,y)]){
            mctx.fillRect(Math.floor(x*tw), Math.floor(y*th), Math.ceil(tw), Math.ceil(th));
          }
        }
      }
    }
  }

  function toggleGrid(){
    state.showGrid = !state.showGrid;
    $('#gridBtn').textContent = state.showGrid ? 'Grid an' : 'Grid aus';
    draw();
  }
  $('#gridBtn').onclick = toggleGrid;

  function download(filename, blob){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
  }
  function saveJSON(){
    const tilesMeta = state.tiles.map(t=>({name:t.name}));
    const payload = {
      tileSize: state.tileSize,
      mapW: state.mapW,
      mapH: state.mapH,
      layers: state.layers.map(L=>({name:L.name, visible:L.visible, data:Array.from(L.data)})),
      tiles: tilesMeta,
      collisions: Array.from(state.collisions||[]),
      meta: state.meta,
      stamps: state.stamps.map(s=>({w:s.w,h:s.h,data:Array.from(s.data)})),
    };
    download('map-pro.json', new Blob([JSON.stringify(payload)], {type:'application/json'}));
    setStatus('JSON exportiert.');
  }
  $('#saveJson').onclick = saveJSON;

  $('#loadJson').onclick = async ()=>{
    const inp = document.createElement('input');
    inp.type='file'; inp.accept='application/json';
    inp.onchange = async (e)=>{
      const file = e.target.files[0]; if(!file) return;
      const text = await file.text();
      const json = JSON.parse(text);
      const prev = structuredClone(state);
      pushHistory({type:'import', prev, next: json});
      state.tileSize = json.tileSize ?? state.tileSize;
      state.mapW = json.mapW ?? state.mapW;
      state.mapH = json.mapH ?? state.mapH;
      state.layers = (json.layers||[]).map(L=>({name:L.name, visible:!!L.visible, data: Int32Array.from(L.data)}));
      state.activeLayer = 0;
      state.collisions = Uint8Array.from(json.collisions || new Array(state.mapW*state.mapH).fill(0));
      state.meta = json.meta || {};
      state.stamps = (json.stamps||[]).map(s=>({w:s.w,h:s.h,data:Int32Array.from(s.data),thumb:document.createElement('canvas')}));
      renderStamps();
      refreshLayers();
      setCanvasSize();
      draw();
      setStatus('JSON importiert. Hinweis: bitte Tiles erneut laden, damit Indizes passen.');
    };
    inp.click();
  };

  $('#exportPng').onclick = ()=>{
    const w = state.mapW*state.tileSize;
    const h = state.mapH*state.tileSize;
    const off = document.createElement('canvas');
    off.width = w; off.height = h;
    const c = off.getContext('2d');
    for(const L of state.layers){
      if(!L.visible) continue;
      for(let y=0;y<state.mapH;y++){
        for(let x=0;x<state.mapW;x++){
          const v = L.data[y*state.mapW+x];
          if(v>=0){
            const t = state.tiles[v]; if(t) c.drawImage(t.img, x*state.tileSize, y*state.tileSize, state.tileSize, state.tileSize);
          }
        }
      }
    }
    off.toBlob((blob)=>download('map.png', blob), 'image/png');
  };

  $('#newProject').onclick = ()=>{
    state.layers = [];
    addLayer('Ground'); addLayer('Objects');
    state.activeLayer = 0;
    state.offX = state.offY = 0;
    state.zoom = 1;
    state.stamps = []; renderStamps();
    state.meta = {};
    state.collisions = new Uint8Array(state.mapW*state.mapH);
    $('#zoomLbl').textContent = '100%';
    refreshLayers();
    draw();
  };
  $('#fitBtn').onclick = ()=>{
    let minx=Infinity,miny=Infinity,maxx=-1,maxy=-1;
    for(const L of state.layers){
      for(let y=0;y<state.mapH;y++){
        for(let x=0;x<state.mapW;x++){
          if(L.data[y*state.mapW+x]>=0){
            if(x<minx)minx=x; if(y<miny)miny=y; if(x>maxx)maxx=x; if(y>maxy)maxy=y;
          }
        }
      }
    }
    if(maxx<0){ setStatus('Keine Kacheln gesetzt.'); return; }
    const wrap = document.getElementById('canvasWrap');
    const w = wrap.clientWidth, h = wrap.clientHeight;
    const margin = 20;
    const tw = (maxx-minx+1)*state.tileSize;
    const th = (maxy-miny+1)*state.tileSize;
    const zx = (w-margin)/tw;
    const zy = (h-margin)/th;
    state.zoom = clamp(Math.min(zx,zy), 0.25, 6);
    $('#zoomLbl').textContent = Math.round(state.zoom*100)+'%';
    const scr = tileToScreen(minx, miny);
    state.offX = margin/2 - scr.x; state.offY = margin/2 - scr.y;
    draw();
  };

  function renderStamps(){
    const box = $('#stamps'); box.innerHTML='';
    state.stamps.forEach((s,i)=>{
      const div = document.createElement('div'); div.className='stamp'; div.dataset.i=i;
      const im = s.thumb;
      if(!im.width){ im.width=s.w*8; im.height=s.h*8; const tc=im.getContext('2d'); tc.fillStyle='#11182a'; tc.fillRect(0,0,im.width,im.height);
        for(let y=0;y<s.h;y++){ for(let x=0;x<s.w;x++){ const v=s.data[idx(x,y,s.w)]; tc.fillStyle=v>=0?'#6aa4ff':'#2a3244'; tc.fillRect(x*8+1,y*8+1,6,6);} } }
      div.appendChild(im);
      const cap = document.createElement('div'); cap.className='badge'; cap.textContent = s.w+'×'+s.h; div.appendChild(cap);
      div.addEventListener('click', ()=>{ state.selectedStamp=i; state.selectedTile=null; $$('.tile').forEach(el=>el.classList.remove('selected')); $$('.stamp').forEach(el=>el.classList.toggle('selected', Number(el.dataset.i)===i)); setTool('stamp'); setStatus('Stempel ausgewählt.'); });
      box.appendChild(div);
    });
  }
  $('#clearStamps').onclick = ()=>{ state.stamps=[]; state.selectedStamp=-1; renderStamps(); };

  $('#resizeBtn').onclick = ()=>{ const w = Number($('#mapW').value); const h = Number($('#mapH').value); resizeMap(w,h); };
  function toggleGrid(){ state.showGrid = !state.showGrid; $('#gridBtn').textContent = state.showGrid ? 'Grid an' : 'Grid aus'; draw(); }
  $('#gridBtn').onclick = toggleGrid;

  ensureActiveLayer();
  refreshLayers();
  setCanvasSize();
  draw();
  setStatus('Tiles laden → malen. Für Stempel: Tool "Stempel", dann Shift‑Ziehen.');
})();
</script>
</body>
</html>
