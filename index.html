<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Siedler‑Mini</title>

  <!-- Bestehende Spiele-Skripte (deine Dateien, Pfade ggf. anpassen) -->
  <script defer src="boot.js"></script>
  <script defer src="game.js"></script>
  <script defer src="tools/map-runtime.js"></script>

  <style>
    :root{
      --bg:#0f2230;
      --panel:#0e1720e6;
      --panelBorder:#203241;
      --text:#d7e3ef;
      --muted:#99a7b3;
      --accent:#36a169;
      --accent-weak:#2a6c49;
      --danger:#e55353;
      --shadow: 0 8px 28px rgba(0,0,0,.35);
      --radius:14px;
      --gap:10px;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      overscroll-behavior:none;
    }

    /* App-Layer */
    #app {
      position:fixed;
      inset:0;
      overflow:hidden; /* wir zoomen nur im Canvas */
    }

    /* Zeichenfläche (nur diese wird gezoomt/verschoben) */
    #stage {
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%) scale(1); /* wird per JS aktualisiert */
      transform-origin: 0 0;
      image-rendering: pixelated;     /* hübsch für Tiles */
      touch-action:none;              /* Pinch/Drag für Canvas aktiv */
      background:transparent;
    }

    /* Debug oben links (fix, skaliert NICHT mit) */
    #debugOverlay{
      position:fixed;
      left:16px;
      top:16px;
      background:var(--panel);
      border:1px solid var(--panelBorder);
      border-radius:12px;
      padding:10px 12px;
      font:14px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      color:var(--text);
      box-shadow:var(--shadow);
      pointer-events:none;
      min-width:260px;
      white-space:pre;
    }

    /* Docked HUD unten links (fix, skaliert NICHT mit) */
    #hud{
      position:fixed;
      left:16px;
      bottom: calc(16px + env(safe-area-inset-bottom));
      background:var(--panel);
      border:1px solid var(--panelBorder);
      border-radius: var(--radius);
      box-shadow:var(--shadow);
      padding:14px;
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;      /* bei wenig Breite 2. Zeile */
      max-width: min(100vw - 32px, 680px);
      z-index:10;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    button{
      appearance:none;
      border:1px solid var(--panelBorder);
      background:#102332;
      color:var(--text);
      border-radius:10px;
      padding:10px 14px;
      font-weight:600;
      touch-action:manipulation;
    }
    button.primary{ background:var(--accent); border-color:var(--accent-weak); color:#06220f; }
    button:disabled{ opacity:.5; }

    select, label.switch {
      background:#0f1c27;
      color:var(--text);
      border:1px solid var(--panelBorder);
      border-radius:10px;
      padding:10px 12px;
      touch-action:manipulation;
    }
    select{ min-width:220px; }

    label.switch{
      display:flex; align-items:center; gap:10px; user-select:none;
    }
    label.switch input{ inline-size:1.25rem; block-size:1.25rem; }

    /* Mobile Safari – Adressleiste: Panels optisch über ihr hinweg */
    @supports (padding: max(0px)) {
      #hud{ bottom: max(16px, env(safe-area-inset-bottom)); }
    }

    /* kleine Screens: Panels etwas kompakter */
    @media (max-width:420px){
      #debugOverlay{ font-size:12px; min-width:220px; }
      select{ min-width:180px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Canvas: NUR dieser Layer wird transformiert -->
    <canvas id="stage" width="2048" height="2048"></canvas>

    <!-- Debug -->
    <pre id="debugOverlay">Cam: x=0.0  y=0.0  zoom=1.00
Map: –
rows=– cols=– tile=–
DPR=–     Size=–×–</pre>

    <!-- HUD (fix angedockt) -->
    <div id="hud" role="region" aria-label="Spiel-Steuerung">
      <div class="row">
        <button id="btnStart" class="primary">Start</button>
        <button id="btnReload">Neu laden</button>
      </div>
      <div class="row">
        <span>Karte:</span>
        <select id="mapSelect" aria-label="Karte wählen">
          <!-- Du kannst diese Liste gern erweitern -->
          <option value="assets/maps/map-demo.json">map-demo.json</option>
          <option value="assets/maps/map-pro.json">map-pro.json</option>
          <option value="assets/maps/map-checker-16x16.json">map-checker (16×16)</option>
        </select>
        <label class="switch" title="Beim Laden automatisch starten">
          <input id="autoStart" type="checkbox" />
          <span>Auto‑Start</span>
        </label>
      </div>
    </div>
  </div>

  <script>
  // ====== UI + Zoom/Pan nur fürs Canvas =====================================

  (function(){
    const canvas = document.getElementById('stage');
    const ctx     = canvas.getContext('2d');
    const hud     = document.getElementById('hud');
    const dbg     = document.getElementById('debugOverlay');
    const sel     = document.getElementById('mapSelect');
    const autoCb  = document.getElementById('autoStart');
    const btnStart= document.getElementById('btnStart');
    const btnReload= document.getElementById('btnReload');

    // Kamera / Transform nur für #stage (nicht fürs UI)
    const camera = {
      x: 0, y: 0, zoom: 1,
      min: 0.5, max: 3.5,
      setZoom(z, cx, cy){
        const prev = this.zoom;
        this.zoom = Math.min(this.max, Math.max(this.min, z));
        // zoomen um den Zeiger: korrigiere Position relativ zum Zoom-Mittelpunkt
        if (cx !== undefined && cy !== undefined){
          const k = this.zoom / prev;
          this.x = cx - k*(cx - this.x);
          this.y = cy - k*(cy - this.y);
        }
        applyTransform();
        maybeForwardToGame();
      },
      pan(dx, dy){
        this.x += dx;
        this.y += dy;
        applyTransform();
        maybeForwardToGame();
      }
    };

    // Canvas initial mittig positionieren (zentriert)
    function applyTransform(){
      // Wir rendern per CSS-Transform NUR das Canvas
      canvas.style.transform =
        `translate(calc(50% + ${camera.x}px), calc(50% + ${camera.y}px)) scale(${camera.zoom})`;
      updateDebug();
    }

    // Debug-Overlay updaten
    function updateDebug(){
      const dpr  = Math.round(devicePixelRatio*100)/100;
      dbg.textContent =
`Cam: x=${camera.x.toFixed(1)}  y=${camera.y.toFixed(1)}  zoom=${camera.zoom.toFixed(2)}
Map: ${sel.value || '–'}
rows=16  cols=16  tile=64
DPR=${dpr}     Size=${innerWidth}×${innerHeight}`;
    }

    // Einfaches Grid, damit Zoomen/Schieben sofort sichtbar ist
    function drawGrid(){
      const w = canvas.width, h = canvas.height, tile=64;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = '#102738';
      ctx.fillRect(0,0,w,h);
      ctx.strokeStyle = 'rgba(255,255,255,.07)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x=0; x<=w; x+=tile){ ctx.moveTo(x,0); ctx.lineTo(x,h); }
      for (let y=0; y<=h; y+=tile){ ctx.moveTo(0,y); ctx.lineTo(w,y); }
      ctx.stroke();
    }

    // ==== Pointer / Wheel (nur auf Canvas aktiv) ============================
    let isPanning=false, last={x:0,y:0};
    let pinchActive=false, pinchDist=0, pinchCenter={x:0,y:0};

    function canvasPointFromEvent(e){
      const rect = canvas.getBoundingClientRect();
      // Koord. im Canvas-Layer (vor Transform)
      const x = e.clientX - rect.left - rect.width/2 - camera.x;
      const y = e.clientY - rect.top  - rect.height/2 - camera.y;
      return { x, y };
    }

    // Wheel-Zoom
    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      const factor = 1 + (delta>0 ? -0.12 : 0.12);
      const p = canvasPointFromEvent(e);
      camera.setZoom(camera.zoom * factor, p.x, p.y);
    }, {passive:false});

    // Pointer: Drag / Pinch
    const activeTouches = new Map();

    canvas.addEventListener('pointerdown', (e)=>{
      canvas.setPointerCapture(e.pointerId);
      activeTouches.set(e.pointerId, {x:e.clientX, y:e.clientY});
      if (activeTouches.size===1){
        isPanning=true;
        last.x=e.clientX; last.y=e.clientY;
      }
      if (activeTouches.size===2){
        pinchActive=true;
        const pts = [...activeTouches.values()];
        pinchDist = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
        pinchCenter = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
      }
    });
    canvas.addEventListener('pointermove', (e)=>{
      if (!activeTouches.has(e.pointerId)) return;
      activeTouches.set(e.pointerId, {x:e.clientX, y:e.clientY});

      if (pinchActive && activeTouches.size===2){
        const pts = [...activeTouches.values()];
        const d = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
        if (d>0){
          const scale = d / pinchDist;
          pinchDist = d;
          // Mittelpunkt ins Canvas-Koordinatensystem
          const rect = canvas.getBoundingClientRect();
          const cx = pinchCenter.x - rect.left - rect.width/2 - camera.x;
          const cy = pinchCenter.y - rect.top  - rect.height/2 - camera.y;
          camera.setZoom(camera.zoom * scale, cx, cy);
        }
      } else if (isPanning && activeTouches.size===1){
        const dx = e.clientX - last.x;
        const dy = e.clientY - last.y;
        last.x = e.clientX; last.y = e.clientY;
        camera.pan(dx, dy);
      }
    });
    function endPointer(e){
      activeTouches.delete(e.pointerId);
      if (activeTouches.size<2) pinchActive=false;
      if (activeTouches.size===0) isPanning=false;
    }
    canvas.addEventListener('pointerup', endPointer);
    canvas.addEventListener('pointercancel', endPointer);
    canvas.addEventListener('pointerleave', endPointer);

    // HUD‑Buttons – Spielaktionen als Events herausgeben
    btnStart.addEventListener('click', ()=>{
      const url = sel.value;
      // 1) Eigene Game-API (optional)
      if (window.GameLoader && typeof window.GameLoader.start === 'function'){
        window.GameLoader.start(url);
      }
      // 2) Event für deine bestehenden Skripte:
      window.dispatchEvent(new CustomEvent('ui:start', { detail:{ map:url }}));
    });

    btnReload.addEventListener('click', ()=>{
      const url = sel.value;
      if (window.GameLoader && typeof window.GameLoader.reload === 'function'){
        window.GameLoader.reload(url);
      }
      window.dispatchEvent(new CustomEvent('ui:reload', { detail:{ map:url }}));
    });

    // Wenn dein Spiel eine Kamera besitzt, reiche Werte weiter:
    function maybeForwardToGame(){
      if (window.GameCamera){
        const c = window.GameCamera;
        if (typeof c.setZoom === 'function') c.setZoom(camera.zoom);
        if (typeof c.setPosition === 'function') c.setPosition(camera.x, camera.y);
      }
    }

    // Autostart, wenn gesetzt
    window.addEventListener('load', ()=>{
      drawGrid();
      applyTransform();
      updateDebug();
      if (autoCb.checked){
        btnStart.click();
      }
    });

    // Falls du aus boot.js/game.js die Map umschaltest:
    window.addEventListener('game:mapLoaded', (e)=>{
      if (e && e.detail && e.detail.mapUrl){
        sel.value = e.detail.mapUrl;
        updateDebug();
      }
    });

    // Sicherstellen, dass Scroll/Zoom des Browsers nicht auf dem Canvas greift:
    // (UI bleibt klickbar, weil touch-action dort auf "manipulation" ist)
    canvas.addEventListener('gesturestart', e=>e.preventDefault());
    canvas.addEventListener('gesturechange', e=>e.preventDefault());
    canvas.addEventListener('gestureend', e=>e.preventDefault());
  })();
  </script>
</body>
</html>
